[리액트 Document](#https://ko.reactjs.org/tutorial/tutorial.html)

개요

1. React란?

- 사용자 인터페이스를 구축하기 위한 선언적이고 효율적이며 유연한 JS 라이브러리이다.
  - component라고 불리는 작고 고립된 코드의 파편을 이용하여 복잡한 UI를 구성하도록 돕는다.

```js
class ShoppingList extends React.Component {
  render() {
    return (
      <div className="shopping-list">
        <h1>Shopping List for {this.props.name}</h1>
        <ul>
          <li>Instagram</li>
          <li>WhatsApp</li>
          <li>Oculus</li>
        </ul>
      </div>
    );
  }
}

// 사용 예제: <ShoppingList name="Mark" />
```

- component를 사용하여 React에게 화면에 표현하고 싶은 것이 무엇인지 알려준다.
- 데이터가 변경될 때 React는 component를 효율적으로 업데이트하고 다시 렌더링한다.
- 위의 예에서 shoppingList는 React 컴포넌트 클래스 또는, React 컴포넌트 타입이다.
  - 개별 컴포넌트는 props라는 매개변수를 받아오고 `render` 함수를 통해 표시할 뷰 계층 구조를 반환한다.

`render 함수`

- 화면에서 보고자 하는 내용을 반환한다.
  - React는 설명을 전달받고 결과를 표시한다.
  - render는 렌더링할 내용을 경량화한 React 엘리먼트를 반환한다. - JSX라는 특수한 문법을 사용하여 React의 구조를 보다 쉽게 작성할 수 있다.
  - <div />구분은 빌드하는 시점에서 React.createElement("div")로 변경된다.

즉, 위의 예는 아래와 같이 변한다.

```js
return React.createElement(
  "div",
  { className: "shopping-list" },
  React.createElement("h1" /* ... h1 children ... */),
  React.createElement("ul" /* ... ul children ... */)
);
```

# JSX

JSX는 JS의 강력한 기능을 갖고 있다.
JSX 내부의 중괄호 안에 어떤 JS 표현식도 사용할 수 있다.
React Element는 JS 객체이며 변수에 저장하거나 프로그램 여기저기에 전달할 수 있다.

# Square

Square 컴포넌트는 <button>을 렌더링한다.

```js
class Square extends React.Component {
  render() {
    return <button className="square">{/* TODO */}</button>;
  }
}
```

# Board

Board 컴포넌트는 사각형 9개를 렌더링한다.

```js
class Board extends React.Component {
  renderSquare(i) {
    return <Square />;
  }

  render() {
    const status = "Next player: X";

    return (
      <div>
        <div className="status">{status}</div>
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}
```

# Game 컴포넌트는 게임판을 렌더링하며 ㄴ중에 수정할 자리 표시자 값을 가지고 있다.

- 초기상태에선 사용자와 상호작용하는 컴포넌트가 없다.

```js
class Game extends React.Component {
  render() {
    return (
      <div className="game">
        <div className="game-board">
          <Board />
        </div>
        <div className="game-info">
          <div>{/* status */}</div>
          <ol>{/* TODO */}</ol>
        </div>
      </div>
    );
  }
}
```

# Props를 통해 데이터 전달하기

Board 컴포넌트에서 Square 컴포넌트로 데이터 전달

- Square에 value prop을 전달학 위해 Board의 renderSquare 함수 코드 수정
- 값을 표시하기 위해 Square의 render 함수에서 {/_TODO_/}를 {this.props.value}로 수정한다.

```js
class Square extends React.Component {
  render() {
    return <button className="square">{this.props.value}</button>;
  }
}

class Board extends React.Component {
  renderSquare(i) {
    return <Square value={i} />;
  }
}
```

변경 후에는 렌더링 된 결과에서 각 사각형에 숫자가 표시된다.

부모 Board 컴포넌트에서 자식 Square 컴포넌트로 prop을 전달했다.

- props 전달하기는 Reat 앱에서 부모에서 자식으로 정보가 어떻게 흘러가는지 알려준다.

# 사용자와 상호작용하는 컴포넌트 만들기

Square 컴포넌트를 클릭하면 "X"가 체크되도록 만든다.

- Square 컴포넌트의 render() 함수에서 반환하는 버튼 태그를 다음과 같이 변경한다.

```js
class Square extends React.Component {
  render() {
    return (
      <button
        className="square"
        onClick={() => {
          console.log("click");
        }}
      >
        {this.props.value}
      </button>
    );
  }
}
```

**주의사항**

# onClick={() => console.log("click")}의 동작과정

onClick prop으로 함수를 전달하고 있다.
React는 클릭했을 때에만 이 함수를 호출한다.
만일, onClick={() => console.log()}가 아닌 onClick={console.log()}이라고 작성한다면 컴포넌트가 다시 렌더링할 때마다 경고 창을 띄운다.

# State

- 무언가를 `기억하기`위해 component는 state를 사용한다.

React 컴포넌트는 생성자에 this.state를 설정하는 것으로 state를 가질 수 있다.
this.state는 정의된 React 컴포넌트에 대해 비공개로 간주해야 한다.

Square의 현재 값을 저장하고 Square를 클릭하는 경우 구현

1. 클래스에 생성자를 추가하여 state를 초기화한다.

```js
class Square extends React.Component {
  constructor(props) {
    super(props);
    // js의 클래스에서 하위 클래스의 생성자를 정의할 때 항상 super를 호출해야 한다.
    // 즉, 모든 React 컴포넌트 클래스는 생성자를 가질 때 super(props) 호출 구문부터 작성해야 한다.
    this.state = {
      value: null,
    };
  }
  render() {
    return (
      <button className="square" onClick={() => console.log("click")}>
        {this.props.value}
      </button>
    );
  }
}
```

2. Square를 클릭할 때 현재 state 값을 표시하기 위해 render 함수 변경

- <button>태그 안 this.props.value를 this.state.value로 변경한다.
- onClick={}이벤트 핸들러를 onClick={() => this.setState({value: "X"})}로 변경한다.
- 가독성을 높이기 위해 className과 onClick props를 별도의 줄에 넣는다.

```js
class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }

  render() {
    return (
      <button
        className="square"
        onClick={() => this.setState({value: "X"})}
      >
      {this.state.value}
      </button>
    )}
```

- Square의 render 함수 내부에서 onClick 핸들러를 통해 this.setState를 호출하는 것으로 React에게 <button>을 클릭할 때 Square가 다시 렌더링해야 한다고 알릴 수 있다.
- 업데이트 이후 Square의 this.state.value는 "X"가 되어 게임 판에서 X가 나타나는 것을 확인할 수 있다.

# 게임 완성하기

현재 게임의 state를 각각의 square 컴포넌트에서 소유하고(유지하고)있다.

- 승자를 확인하기 위해 9개 사각형의 값을 한 곳에서 소유하도록(유지하도록) 한다.

Board가 각 Square에 Square의 state를 요청하게 할 수 있지만 코드를 이해하기 어렵게 만들고 버그에 취약하여 리팩토링이 어렵기 때문에 지양해야 한다.

- 즉, 각 Square가 아닌 부모 Board 컴포넌트에 게임의 상태(state)를 저장하는 것이 가장 좋은 방법이다.
- 각 Square에 숫자를 넘겨주었을 때와 같이 Board 컴포넌트는 각 Square에게 prop을 전달하는 것으로 무엇을 표시할지 알려준다.

`여러개의 자식으로부터 데이터를 모으거나 두 개의 자식 컴포넌트들이 서로 통신하게 하렴녀 부모 컴포넌트에 공유 state를 정의해야 한다. 부모 컴포는트는 props를 사용하여 자식 컴포넌트에 state를 다시 전달할 수 있다. 이것은 자식 컴포넌트들이 서로 또는 부모 컴포넌트와 동기화 하도록 만든다.`

- state를 부모 컴포넌트로 끌어올리는 것은 React 컴포넌트를 리팩토링할 때 흔히 사용한다.

Board에 생성자를 추가하고 9개의 사각형에 해당하는 9개의 null 배열을 초기 state로 설정한다.

```js
class Board extends React.Component{
  constructor(props){
    super(props);
    this.state={
      squares: Array(9).fill(null), // 9개의 null 배열을 초기 state로 설정한다.
    };
  }
  renderSquare(i){
    return <Square value={i}>;
  }
}
```

Array.prototype.fill()

- fill() 메서드는 배열의 시작 인덱스부터 끝 인덱스의 이전까지 정적인 하나의 값으로 채운다.

추후 board를채우면 this.state.squares 배열은 아래와 같이 보인다.

```js
["O", null, "X", "X", "X", "O", "O", null, null];
```

처음에는 모든 Square에서 0부터 8까지 숫자를 보여주기 위해 Board에서 value prop을 자식으로 전달했다.
또 다른 이전 단계에서는 숫자를 Square의 자체 state에 따라 "X" 표시로 바꿨다. 그렇기 때문에 현재 Square는 Board에서 전달한 value prop을 무시하고 있다.

이제 prop을 전달하는 방법을 다시 사용한다.
각 Square에게 현재 값("X", "O", null)을 표현하도록 Board를 수정한다.

- Board의 생성자에서 squares 배열을 이미 선언했으며, renderSquare 함수를 아래와 같이 수정한다.

```js
renderSquare(i){
  return <Square value={this.state.squares[i]}>;
}
```

이제 Square는 빈 사각형에 "X", "O", null인 value prop을 받는다.

다음으로 Square를 클릭할 때 발생하는 변화가 필요하다.
Board 컴포넌트는 어떤 사각형이 채워졌는지의 여부를 관리하므로 Square가 Board를 변경할 방법이 필요하다.
컴포넌트는 자신이 정의한 state에만 접근할 수 있으므로 Square에서 Board의 state를 직접 변경할 수 없다.

- 대신에 Board에서 Square로 함수를 전달하고 Square는 사각형을 클릭할 때 함수를 호출한다.
  이제 Board의 renderSquare 함수를 아래와 같이 변경한다.

```js
renderSquare(i){
  return(
    <Square
      value={this.state.square[i]}
      onClick={() => this.handleClick(i)}
    />
  )
}
```

이제 Board에서 Square로 value와 onClick 두 개의 props를 전달했다.
onClick은 Square를 클릭하면호출되는 함수이기에 Square를 다음과 같이 변경한다.

- Square의 render 함수 내부의 this.state.value를 this.props.value로 변경한다.
- Square의 render 함수 내부의 this.setState()를 this.props.onClick()으로 변경한다.
- Square는 게임의 상태를유지할 필요가 없기에 constructor를 지운다.

```js
class Square extends React.Component {
  render() {
    return (
      <button className="square" onClick={() => this.props.onClick()}>
        {this.props.value}
      </button>
    );
  }
}
```

Square를 클릭하면 Board에서 넘겨받은 onClick 함수가 호출된다.
이때 일어나는 일의 과정

1. 내장된 DOM <button> 컴포넌트에 있는 onClick prop은 React에게 클릭 이벤트 리스너를 설정하라고 알려준다.
2. 버튼을 클릭하면 React는 Square의 render() 함수에 정의된 onClick 이벤트 핸들러를 호출한다.
3. 이벤트 헨들러는 this.props.onClick()를 호출한다. Square의 onClick prop은 Board에서 정의되었다.
4. Board에서 Square로 onClick={() => this.handleClick(i)}를 전달했기 때문에 Square를 클릭하면 Board의 handleClick(i)를 호출한다.
5. 아직 handleClick()을 정의하지 않았기 때문에 코드가 깨진다.

- 사각형을 클릭하면 "this.handleClick is not a function"과 같은 붉은 에러 화면이 출력된다.

Board 클래스에 handleClick 추가

```js
handleClick(i){
  const squares = this.state.squares.slice();
  squares[i]="X";
  this.setState({squares: squares});
}
```

현재까지 요약

Square를 클릭하여 사각형을 채울 수 있다.
그러나 이제는 state가 각 Square 컴포넌트 대신 Board 컴포넌트에 저장된다.
Board의 상태가 변화할 떄 Square 컴포넌트는 자동으로 다시 렌더링한다.
Board 컴포넌트의 모든 사각형의 상태를 유지하는 것으로 이후에 승자를 결정하는 것이 간으하다.

Square 컴포넌트가 더 이상 state를 유지하지 않기 때문에 Square 컴포넌트는 Board 컴포넌트에서 값을 받아 클릭될 때 Board 컴포넌트로 정보를 전달한다.

- React 용어로 Square 컴포넌트는 이제 제어되는 컴포넌트이다. Board는 이들을 완전히 제어한다.

handleClick에서는 .slice()를 호출하는 것으로 기존 배열을 수정하지 않고 squares 배열의 복사본을 생성하여 수정한다.

# 불변성

데이터 변경 방법에는 2가지 방법이 있다.

1. 데이터의 값을 직접 변경한다.
2. 원하는 변경 값을 가진 새로운 사본으로 데이터를 교체한다.

객체 변경을 통한 데이터 수정

```js
var player = {
  score: 1,
  name: "Jeff",
};
player.score = 2;
// 이제 player는 {
//   score: 2,
//   name: "Jeff"
// }
// 이다.
```

객체 변경 없이 데이터 수정하기

```js
var player = {
  score: 1,
  name: "Jeff",
};
var newPlayer = Object.assign({}, player, { score: 2 });
// 이제 player는 변하지 않았지만 newPlayer는 {score: 2, name: "Jeff"}이다.

// 객체 speard 구문을 이용하면 아래와 같이 사용할 수 있다.
var newPlayer = { ...player, score: 2 };
```

최종 결과는 동일하지만, 객체 변경이나 기본 데이터의 변경을 하지 않는다면(불변성을 지킨다면) 아래와 같은 이점을 얻을 수 있다.

1. 복잡한 특징을 단순하게 만든다.

- 불변성은 복잡한 특징들을 구현하기 쉽게만든다.
  - ex) 특정 행동을 취소하고 다시 실행하는 기능
- 즉, 직접적인 데이터 변이를 피하는 것은 이전 버전의 게임 이력을 유지하고 나중에 재사용할 수 있게 만든다.

2. 변화를 감지할 수 있다.

- 객체가 직접적으로 수정되기 때문에 복제가 가능한 객체에서 변화를 감지하는 것은 어렵다.
  - 감지는 복제가 가능한 객체를 이전 사본과 비교하고 전체 객체트리를 돌아야 한다.
- 불변 객체에서 변화를 감지하는 것은 상당히 쉽다.
  - 참조하고 있는 불변 객체가 이전 객체와 다르다면 객체는 변한 것임을 알 수 있다.

3. React에서 다시 렌더링하는 시기를 결정할 수 있다.

- 불변성의 가장 큰 장점은 React에서 순수 컴포넌트를 만드는데 도움을 준다는 것이다.
- 변하지 않는 데이터는 변경이 이뤄졌는지 쉽게 판단할 수 있으며, 이를 바탕으로 컴포넌트가 다시 렌더링할지를 결정할 수 있다.
